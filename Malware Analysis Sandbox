import os
import subprocess
import hashlib
import time
import psutil
import shutil
from datetime import datetime

class MalwareAnalysisSandbox:
    
    def __init__(self, malware_path):
        self.malware_path = malware_path
        self.sandbox_directory = "sandbox"
        self.network_log_file = "network_log.txt"
        self.file_system_log_file = "file_system_log.txt"
        self.process_log_file = "process_log.txt"

    def create_sandbox(self):
        if not os.path.exists(self.sandbox_directory):
            os.mkdir(self.sandbox_directory)
            print(f"[INFO] Sandbox environment created at '{self.sandbox_directory}'")
        else:
            print(f"[INFO] Sandbox environment already exists at '{self.sandbox_directory}'")

    def copy_malware_to_sandbox(self):
        malware_basename = os.path.basename(self.malware_path)
        sandbox_malware_path = os.path.join(self.sandbox_directory, malware_basename)
        shutil.copy2(self.malware_path, sandbox_malware_path)
        print(f"[INFO] Malware copied to sandbox: '{sandbox_malware_path}'")
        return sandbox_malware_path

    def calculate_file_hash(self, file_path):
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()

    def monitor_processes(self, duration=60):
        print(f"[INFO] Monitoring processes for {duration} seconds")
        start_time = time.time()
        initial_processes = {p.pid for p in psutil.process_iter(['pid'])}
        with open(self.process_log_file, "a") as log_file:
            while time.time() - start_time < duration:
                current_processes = {p.pid for p in psutil.process_iter(['pid'])}
                new_processes = current_processes - initial_processes
                for pid in new_processes:
                    try:
                        p = psutil.Process(pid)
                        log_file.write(f"[{datetime.now()}] New Process: {p.name()} (PID: {pid})\n")
                        print(f"[INFO] New Process Detected: {p.name()} (PID: {pid})")
                    except psutil.NoSuchProcess:
                        continue
                time.sleep(5)

    def monitor_file_system(self):
        print(f"[INFO] Monitoring file system in '{self.sandbox_directory}'")
        initial_snapshot = {f: os.path.getmtime(os.path.join(self.sandbox_directory, f)) for f in os.listdir(self.sandbox_directory)}
        with open(self.file_system_log_file, "a") as log_file:
            while True:
                time.sleep(2)
                current_snapshot = {f: os.path.getmtime(os.path.join(self.sandbox_directory, f)) for f in os.listdir(self.sandbox_directory)}
                added = set(current_snapshot.keys()) - set(initial_snapshot.keys())
                removed = set(initial_snapshot.keys()) - set(current_snapshot.keys())
                modified = {f for f in current_snapshot if f in initial_snapshot and current_snapshot[f] != initial_snapshot[f]}

                for f in added:
                    log_file.write(f"[{datetime.now()}] File Added: {f}\n")
                    print(f"[INFO] File Added: {f}")

                for f in removed:
                    log_file.write(f"[{datetime.now()}] File Removed: {f}\n")
                    print(f"[INFO] File Removed: {f}")

                for f in modified:
                    log_file.write(f"[{datetime.now()}] File Modified: {f}\n")
                    print(f"[INFO] File Modified: {f}")

                initial_snapshot = current_snapshot

    def monitor_network_activity(self, duration=60):
        print(f"[INFO] Monitoring network activity for {duration} seconds")
        start_time = time.time()
        with open(self.network_log_file, "a") as log_file:
            while time.time() - start_time < duration:
                try:
                    connections = psutil.net_connections(kind='inet')
                    for conn in connections:
                        if conn.status == psutil.CONN_ESTABLISHED:
                            remote_ip = conn.raddr.ip
                            remote_port = conn.raddr.port
                            log_file.write(f"[{datetime.now()}] Established connection: {remote_ip}:{remote_port}\n")
                            print(f"[INFO] Established connection: {remote_ip}:{remote_port}")
                except psutil.AccessDenied:
                    continue
                time.sleep(2)

    def execute_malware(self, sandbox_malware_path):
        try:
            print(f"[INFO] Executing malware '{sandbox_malware_path}'")
            subprocess.run(sandbox_malware_path, shell=True, timeout=10)  # Set a timeout to prevent indefinite execution
        except subprocess.TimeoutExpired:
            print("[WARNING] Malware execution timed out.")

    def cleanup_sandbox(self):
        if os.path.exists(self.sandbox_directory):
            shutil.rmtree(self.sandbox_directory)
            print(f"[INFO] Sandbox environment cleaned up.")

    def run_analysis(self):
        self.create_sandbox()
        sandbox_malware_path = self.copy_malware_to_sandbox()

        print(f"[INFO] Initial file hash: {self.calculate_file_hash(sandbox_malware_path)}")

        # Start monitoring in parallel
        import threading
        process_monitor_thread = threading.Thread(target=self.monitor_processes)
        file_system_monitor_thread = threading.Thread(target=self.monitor_file_system)
        network_monitor_thread = threading.Thread(target=self.monitor_network_activity)

        # Start the threads
        process_monitor_thread.start()
        file_system_monitor_thread.start()
        network_monitor_thread.start()

        # Execute malware
        self.execute_malware(sandbox_malware_path)

        # Wait for monitors to finish
        process_monitor_thread.join()
        network_monitor_thread.join()
        file_system_monitor_thread.join()

        # Cleanup sandbox
        self.cleanup_sandbox()

if __name__ == "__main__":
    malware_path = input("Enter the path of the malware to analyze: ")
    sandbox = MalwareAnalysisSandbox(malware_path)
    sandbox.run_analysis()
